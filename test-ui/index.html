<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Semfora Daemon Test UI</title>
    <style>
        :root {
            --bg: #1a1a2e;
            --surface: #16213e;
            --primary: #0f3460;
            --accent: #e94560;
            --text: #eee;
            --text-dim: #888;
            --success: #4ade80;
            --error: #f87171;
        }
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            padding: 20px;
        }
        h1 {
            color: var(--accent);
            margin-bottom: 20px;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .panel {
            background: var(--surface);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }
        .panel h2 {
            color: var(--accent);
            font-size: 14px;
            text-transform: uppercase;
            margin-bottom: 10px;
            letter-spacing: 1px;
        }
        .row {
            display: flex;
            gap: 15px;
        }
        .col {
            flex: 1;
        }
        input, select, button {
            background: var(--primary);
            border: 1px solid var(--text-dim);
            color: var(--text);
            padding: 8px 12px;
            border-radius: 4px;
            font-family: inherit;
            font-size: 14px;
        }
        input:focus, select:focus {
            outline: none;
            border-color: var(--accent);
        }
        button {
            background: var(--accent);
            border: none;
            cursor: pointer;
            transition: opacity 0.2s;
        }
        button:hover {
            opacity: 0.8;
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .status {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
        }
        .status.connected {
            background: rgba(74, 222, 128, 0.2);
            color: var(--success);
        }
        .status.disconnected {
            background: rgba(248, 113, 113, 0.2);
            color: var(--error);
        }
        .dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
        }
        .log {
            background: var(--bg);
            border-radius: 4px;
            padding: 10px;
            height: 200px;
            overflow-y: auto;
            font-size: 12px;
            line-height: 1.5;
        }
        .log-entry {
            padding: 2px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }
        .log-entry.sent {
            color: #93c5fd;
        }
        .log-entry.received {
            color: #86efac;
        }
        .log-entry.error {
            color: var(--error);
        }
        .log-entry.info {
            color: var(--text-dim);
        }
        .log-timestamp {
            color: var(--text-dim);
            margin-right: 8px;
        }
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
        }
        .info-item {
            background: var(--bg);
            padding: 10px;
            border-radius: 4px;
        }
        .info-label {
            color: var(--text-dim);
            font-size: 11px;
            text-transform: uppercase;
            margin-bottom: 4px;
        }
        .info-value {
            font-size: 14px;
            word-break: break-all;
        }
        .query-form {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        .query-form input {
            flex: 1;
        }
        .results {
            background: var(--bg);
            border-radius: 4px;
            padding: 10px;
            max-height: 300px;
            overflow-y: auto;
            font-size: 12px;
        }
        pre {
            white-space: pre-wrap;
            word-break: break-word;
        }
        .tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }
        .tab {
            background: var(--primary);
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        .tab.active {
            background: var(--accent);
        }
        .worktree-list, .index-list {
            list-style: none;
        }
        .worktree-list li, .index-list li {
            background: var(--bg);
            padding: 8px;
            border-radius: 4px;
            margin-bottom: 5px;
            font-size: 12px;
        }
        .badge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 10px;
            margin-left: 5px;
        }
        .badge.semfora {
            background: var(--accent);
        }
        .badge.ready {
            background: var(--success);
            color: #000;
        }
        /* Call Graph Styles */
        .call-graph-container {
            display: grid;
            grid-template-columns: 250px 1fr;
            gap: 15px;
            min-height: 500px;
        }
        .symbol-list-panel {
            background: var(--bg);
            border-radius: 4px;
            padding: 10px;
            overflow-y: auto;
            max-height: 500px;
        }
        .symbol-search {
            width: 100%;
            margin-bottom: 10px;
        }
        .symbol-list {
            list-style: none;
        }
        .symbol-list li {
            padding: 6px 8px;
            cursor: pointer;
            border-radius: 4px;
            margin-bottom: 2px;
            font-size: 12px;
            transition: background 0.2s;
        }
        .symbol-list li:hover {
            background: var(--primary);
        }
        .symbol-list li.selected {
            background: var(--accent);
        }
        .symbol-kind {
            display: inline-block;
            width: 60px;
            font-size: 10px;
            color: var(--text-dim);
            text-transform: uppercase;
        }
        .symbol-module {
            font-size: 10px;
            color: var(--text-dim);
            display: block;
            margin-left: 60px;
        }
        .call-graph-view {
            background: var(--bg);
            border-radius: 4px;
            padding: 15px;
            overflow: auto;
        }
        .graph-section {
            margin-bottom: 20px;
        }
        .graph-section-title {
            color: var(--accent);
            font-size: 12px;
            text-transform: uppercase;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .graph-section-title .arrow {
            font-size: 16px;
        }
        .center-symbol {
            background: var(--accent);
            padding: 12px 16px;
            border-radius: 6px;
            margin: 15px 0;
            text-align: center;
        }
        .center-symbol .name {
            font-size: 16px;
            font-weight: bold;
        }
        .center-symbol .meta {
            font-size: 11px;
            color: rgba(255,255,255,0.7);
            margin-top: 4px;
        }
        .tree-node {
            padding-left: 20px;
            border-left: 2px solid var(--primary);
            margin-left: 10px;
        }
        .tree-item {
            padding: 6px 10px;
            background: var(--surface);
            border-radius: 4px;
            margin: 4px 0;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-block;
            min-width: 200px;
        }
        .tree-item:hover {
            background: var(--primary);
            transform: translateX(3px);
        }
        .tree-item .name {
            font-size: 13px;
        }
        .tree-item .kind {
            font-size: 10px;
            color: var(--text-dim);
            margin-left: 8px;
        }
        .tree-item .module {
            font-size: 10px;
            color: var(--text-dim);
            display: block;
        }
        .tree-item.has-children {
            position: relative;
        }
        .tree-item.has-children::after {
            content: '+';
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-dim);
        }
        .tree-item.expanded::after {
            content: '-';
        }
        .no-data {
            color: var(--text-dim);
            font-style: italic;
            font-size: 12px;
            padding: 10px;
        }
        .depth-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        .depth-control label {
            font-size: 12px;
            color: var(--text-dim);
        }
        .depth-control input[type="range"] {
            width: 100px;
        }
        .stats-bar {
            display: flex;
            gap: 15px;
            margin-bottom: 10px;
            font-size: 11px;
            color: var(--text-dim);
        }
        .stats-bar .stat {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .stats-bar .stat-value {
            color: var(--accent);
            font-weight: bold;
        }
        /* Connected Repos Cards */
        .repo-card {
            background: var(--bg);
            border-radius: 6px;
            padding: 12px;
            border-left: 3px solid var(--accent);
        }
        .repo-card.active {
            border-left-color: var(--success);
        }
        .repo-card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
        }
        .repo-card-name {
            font-size: 14px;
            font-weight: bold;
            color: var(--text);
        }
        .repo-card-path {
            font-size: 10px;
            color: var(--text-dim);
            word-break: break-all;
            margin-bottom: 6px;
        }
        .repo-card-stats {
            display: flex;
            gap: 12px;
            font-size: 11px;
        }
        .repo-card-stat {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .repo-card-stat .label {
            color: var(--text-dim);
        }
        .repo-card-stat .value {
            color: var(--accent);
            font-weight: bold;
        }
        .repo-card-indexes {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }
        .repo-card-index {
            display: inline-block;
            background: var(--primary);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 10px;
            margin-right: 5px;
            margin-bottom: 4px;
        }
        .repo-card-index.ready {
            background: rgba(74, 222, 128, 0.2);
            color: var(--success);
        }
        /* Event log entry types */
        .log-entry.event {
            color: #c084fc;
        }
        .log-entry.event-repo {
            border-left: 3px solid var(--accent);
            padding-left: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Semfora Daemon Test UI</h1>

        <!-- Connection Panel -->
        <div class="panel">
            <h2>Connection</h2>
            <div class="row">
                <div class="col">
                    <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                        <input type="text" id="serverUrl" value="ws://127.0.0.1:9847" placeholder="WebSocket URL" style="width: 200px;">
                        <button id="connectBtn" onclick="toggleConnection()">Connect</button>
                        <span id="connectionStatus" class="status disconnected">
                            <span class="dot"></span>
                            Disconnected
                        </span>
                    </div>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <select id="repoPresets" onchange="selectRepoPreset()">
                            <option value="">-- Quick Connect --</option>
                            <option value="/home/kadajett/Dev/Semfora_org/pokemon-test">Pokemon Test</option>
                            <option value="/home/kadajett/Dev/next.js">Next.js</option>
                            <option value="/home/kadajett/Dev/semfora-test-repos/repos/angular-realworld">Angular Realworld</option>
                        </select>
                        <input type="text" id="repoPath" value="/home/kadajett/Dev/Semfora_org/pokemon-test" placeholder="Repository path" style="flex: 1;">
                        <button id="connectRepoBtn" onclick="connectToRepo()" disabled>Connect to Repo</button>
                    </div>
                    <div style="margin-top: 10px;">
                        <button id="connectAllBtn" onclick="connectAllRepos()" disabled style="background: #16a34a;">Connect All 3 Repos</button>
                        <span id="multiRepoStatus" style="margin-left: 10px; font-size: 12px; color: var(--text-dim);"></span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Connected Repos Panel -->
        <div class="panel">
            <h2>Connected Repositories (<span id="repoCount">0</span>)</h2>
            <div id="connectedRepos" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 15px;">
                <div class="no-data">No repositories connected yet. Use "Connect All 3 Repos" or connect individually.</div>
            </div>
        </div>

        <!-- Event Log Panel -->
        <div class="panel">
            <h2>Event Stream <span id="eventCount" style="font-size: 11px; color: var(--text-dim);">(0 events)</span></h2>
            <div class="log" id="eventLog" style="height: 150px;">
                <div class="no-data">Events will appear here when files change...</div>
            </div>
            <button onclick="clearEventLog()" style="margin-top: 10px; background: var(--primary);">Clear Events</button>
        </div>

        <!-- Queries Panel -->
        <div class="panel">
            <h2>Queries</h2>
            <div class="tabs">
                <div class="tab active" onclick="selectTab('search')">Search Symbols</div>
                <div class="tab" onclick="selectTab('overview')">Get Overview</div>
                <div class="tab" onclick="selectTab('worktrees')">List Worktrees</div>
                <div class="tab" onclick="selectTab('callgraph')">Call Graph JSON</div>
                <div class="tab" onclick="selectTab('custom')">Custom Query</div>
            </div>

            <div id="searchTab">
                <div class="query-form">
                    <input type="text" id="searchQuery" placeholder="Search query (e.g., App, fetch, useState)">
                    <button onclick="searchSymbols()">Search</button>
                </div>
            </div>

            <div id="overviewTab" style="display: none;">
                <button onclick="getOverview()">Get Repository Overview</button>
            </div>

            <div id="worktreesTab" style="display: none;">
                <button onclick="listWorktrees()">Refresh Worktrees</button>
            </div>

            <div id="callgraphTab" style="display: none;">
                <button onclick="getCallGraph()">Get Call Graph</button>
            </div>

            <div id="customTab" style="display: none;">
                <div class="query-form">
                    <input type="text" id="customMethod" placeholder="Method (e.g., get_repo_info)">
                    <input type="text" id="customParams" placeholder='Params JSON (e.g., {"query": "App"})'>
                    <button onclick="customQuery()">Send</button>
                </div>
            </div>

            <div class="results" id="results">
                <pre>Results will appear here...</pre>
            </div>
        </div>

        <!-- Call Graph Viewer Panel -->
        <div class="panel">
            <h2>Call Graph Viewer</h2>
            <!-- Scope Selector -->
            <div style="margin-bottom: 15px; display: flex; gap: 10px; align-items: center;">
                <label style="font-size: 12px; color: var(--text-dim);">Index Scope:</label>
                <select id="callGraphScope" style="flex: 1; max-width: 400px;" onchange="onScopeChange()">
                    <option value="">-- Connect to repo first --</option>
                </select>
                <span id="scopeSymbolCount" style="font-size: 11px; color: var(--text-dim);"></span>
            </div>
            <div class="call-graph-container">
                <!-- Symbol List -->
                <div class="symbol-list-panel">
                    <input type="text" class="symbol-search" id="symbolSearch" placeholder="Filter symbols..." oninput="filterSymbols()">
                    <div class="depth-control">
                        <label>Depth:</label>
                        <input type="range" id="graphDepth" min="1" max="5" value="2" oninput="updateDepthLabel()">
                        <span id="depthLabel">2</span>
                    </div>
                    <button onclick="loadSymbolList()" style="width: 100%; margin-bottom: 10px;">Load Symbols</button>
                    <ul class="symbol-list" id="symbolListView">
                        <li class="no-data">Select a scope and click "Load Symbols"</li>
                    </ul>
                </div>

                <!-- Call Graph Visualization -->
                <div class="call-graph-view" id="callGraphView">
                    <div class="no-data">Select a symbol from the list to view its call graph</div>
                </div>
            </div>
        </div>

        <!-- Subscriptions Panel -->
        <div class="panel">
            <h2>Event Subscriptions</h2>
            <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                <select id="eventType">
                    <option value="base_branch">base_branch</option>
                    <option value="feature_branch">feature_branch</option>
                    <option value="active_worktree">active_worktree</option>
                    <option value="repo">repo</option>
                    <option value="*">* (all)</option>
                </select>
                <button onclick="subscribe()">Subscribe</button>
                <button onclick="unsubscribe()">Unsubscribe</button>
            </div>
            <div id="activeSubscriptions" style="font-size: 12px; color: var(--text-dim);">
                Active: none
            </div>
        </div>

        <!-- Log Panel -->
        <div class="panel">
            <h2>Message Log</h2>
            <div class="log" id="log"></div>
        </div>
    </div>

    <script>
        let ws = null;
        let queryId = 1;
        let subscriptions = [];
        let connectedRepos = {}; // repo_id -> connection info
        let eventCount = 0;

        function log(message, type = 'info') {
            const logEl = document.getElementById('log');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            const time = new Date().toLocaleTimeString();
            entry.innerHTML = `<span class="log-timestamp">${time}</span>${message}`;
            logEl.appendChild(entry);
            logEl.scrollTop = logEl.scrollHeight;
        }

        function updateStatus(connected) {
            const status = document.getElementById('connectionStatus');
            const connectBtn = document.getElementById('connectBtn');
            const connectRepoBtn = document.getElementById('connectRepoBtn');
            const connectAllBtn = document.getElementById('connectAllBtn');

            if (connected) {
                status.className = 'status connected';
                status.innerHTML = '<span class="dot"></span>Connected';
                connectBtn.textContent = 'Disconnect';
                connectRepoBtn.disabled = false;
                connectAllBtn.disabled = false;
            } else {
                status.className = 'status disconnected';
                status.innerHTML = '<span class="dot"></span>Disconnected';
                connectBtn.textContent = 'Connect';
                connectRepoBtn.disabled = true;
                connectAllBtn.disabled = true;
            }
        }

        function selectRepoPreset() {
            const select = document.getElementById('repoPresets');
            const input = document.getElementById('repoPath');
            if (select.value) {
                input.value = select.value;
            }
        }

        const DEFAULT_REPOS = [
            '/home/kadajett/Dev/Semfora_org/pokemon-test',
            '/home/kadajett/Dev/next.js',
            '/home/kadajett/Dev/semfora-test-repos/repos/angular-realworld'
        ];

        let multiRepoConnectIndex = 0;

        function connectAllRepos() {
            multiRepoConnectIndex = 0;
            document.getElementById('multiRepoStatus').textContent = 'Connecting to repos...';
            connectNextRepo();
        }

        function connectNextRepo() {
            if (multiRepoConnectIndex < DEFAULT_REPOS.length) {
                const repo = DEFAULT_REPOS[multiRepoConnectIndex];
                document.getElementById('multiRepoStatus').textContent =
                    `Connecting ${multiRepoConnectIndex + 1}/${DEFAULT_REPOS.length}: ${repo.split('/').pop()}...`;
                send({ type: 'connect', directory: repo });
                multiRepoConnectIndex++;
                // Wait a bit for the connection to complete before connecting the next one
                setTimeout(connectNextRepo, 500);
            } else {
                document.getElementById('multiRepoStatus').textContent =
                    `All ${DEFAULT_REPOS.length} repos connected!`;
            }
        }

        // Auto-subscribe to all events after WebSocket connects
        function autoSubscribeToEvents() {
            send({ type: 'subscribe', events: ['*'] });
            log('Auto-subscribed to all events (*)', 'info');
        }

        // Render all connected repos as cards
        function renderConnectedRepos() {
            const container = document.getElementById('connectedRepos');
            const repoIds = Object.keys(connectedRepos);
            document.getElementById('repoCount').textContent = repoIds.length;

            if (repoIds.length === 0) {
                container.innerHTML = '<div class="no-data">No repositories connected yet. Use "Connect All 3 Repos" or connect individually.</div>';
                return;
            }

            container.innerHTML = repoIds.map(repoId => {
                const repo = connectedRepos[repoId];
                const name = repo.base_repo_path.split('/').pop();
                const totalSymbols = (repo.indexes || []).reduce((sum, idx) => sum + (idx.symbol_count || 0), 0);
                const worktreeCount = (repo.worktrees || []).length;
                const indexCount = (repo.indexes || []).length;

                return `
                    <div class="repo-card active" data-repo-id="${repoId}">
                        <div class="repo-card-header">
                            <span class="repo-card-name">${escapeHtml(name)}</span>
                            <span class="status connected" style="font-size: 10px; padding: 2px 8px;">
                                <span class="dot"></span>
                                ${repo.client_id}
                            </span>
                        </div>
                        <div class="repo-card-path">${escapeHtml(repo.base_repo_path)}</div>
                        <div class="repo-card-stats">
                            <div class="repo-card-stat">
                                <span class="label">Branch:</span>
                                <span class="value">${repo.base_branch || 'unknown'}</span>
                            </div>
                            <div class="repo-card-stat">
                                <span class="label">Worktrees:</span>
                                <span class="value">${worktreeCount}</span>
                            </div>
                            <div class="repo-card-stat">
                                <span class="label">Total Symbols:</span>
                                <span class="value">${totalSymbols.toLocaleString()}</span>
                            </div>
                        </div>
                        <div class="repo-card-indexes">
                            ${(repo.indexes || []).map(idx => `
                                <span class="repo-card-index ${idx.status === 'ready' ? 'ready' : ''}"
                                      title="${idx.scope}: ${idx.symbol_count} symbols">
                                    ${idx.scope} (${idx.symbol_count})
                                </span>
                            `).join('')}
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Add event to the event log
        function logEvent(eventName, payload, repoPath) {
            eventCount++;
            document.getElementById('eventCount').textContent = `(${eventCount} events)`;

            const logEl = document.getElementById('eventLog');
            // Clear "no data" message if present
            if (logEl.querySelector('.no-data')) {
                logEl.innerHTML = '';
            }

            const entry = document.createElement('div');
            entry.className = 'log-entry event event-repo';
            const time = new Date().toLocaleTimeString();
            const repoName = repoPath ? repoPath.split('/').pop() : 'unknown';

            // Parse payload for file info if available
            let details = '';
            if (payload) {
                if (payload.files && payload.files.length > 0) {
                    details = ` - ${payload.files.length} file(s): ${payload.files.slice(0, 3).join(', ')}${payload.files.length > 3 ? '...' : ''}`;
                } else if (payload.file) {
                    details = ` - ${payload.file}`;
                } else if (typeof payload === 'string') {
                    details = ` - ${payload}`;
                }
            }

            entry.innerHTML = `<span class="log-timestamp">${time}</span><strong>[${escapeHtml(repoName)}]</strong> ${escapeHtml(eventName)}${details}`;
            logEl.appendChild(entry);
            logEl.scrollTop = logEl.scrollHeight;
        }

        function clearEventLog() {
            eventCount = 0;
            document.getElementById('eventCount').textContent = '(0 events)';
            document.getElementById('eventLog').innerHTML = '<div class="no-data">Events will appear here when files change...</div>';
        }

        // Try to find the repo path from event data by matching scope or path fragments
        function findRepoPathForEvent(msg) {
            // Try to match by scope name in the event
            const scope = msg.payload?.scope || msg.scope;
            if (scope) {
                for (const repo of Object.values(connectedRepos)) {
                    for (const idx of (repo.indexes || [])) {
                        if (idx.scope === scope) {
                            return repo.base_repo_path;
                        }
                    }
                }
            }
            // Try to match by path in the event payload
            const filePath = msg.payload?.file || msg.payload?.path;
            if (filePath) {
                for (const repo of Object.values(connectedRepos)) {
                    if (filePath.startsWith(repo.base_repo_path)) {
                        return repo.base_repo_path;
                    }
                }
            }
            // Return first repo if only one connected
            const repos = Object.values(connectedRepos);
            if (repos.length === 1) {
                return repos[0].base_repo_path;
            }
            return null;
        }

        function toggleConnection() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.close();
            } else {
                connect();
            }
        }

        function connect() {
            const url = document.getElementById('serverUrl').value;
            log(`Connecting to ${url}...`);

            ws = new WebSocket(url);

            ws.onopen = () => {
                log('WebSocket connected', 'received');
                updateStatus(true);
                // Auto-subscribe to all events
                setTimeout(autoSubscribeToEvents, 100);
            };

            ws.onmessage = (event) => {
                log(`← ${event.data}`, 'received');
                handleMessage(JSON.parse(event.data));
            };

            ws.onerror = (error) => {
                log(`Error: ${error.message || 'Connection error'}`, 'error');
            };

            ws.onclose = () => {
                log('WebSocket disconnected', 'info');
                updateStatus(false);
                // Clear connected repos on disconnect
                connectedRepos = {};
                renderConnectedRepos();
                subscriptions = [];
                updateSubscriptions();
            };
        }

        function send(obj) {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                log('Not connected!', 'error');
                return;
            }
            const json = JSON.stringify(obj);
            log(`→ ${json}`, 'sent');
            // Console log for debugging
            console.log('%c[WS SEND]', 'color: #93c5fd; font-weight: bold', obj);
            ws.send(json);
        }

        function handleMessage(msg) {
            // Console log for debugging
            console.log('%c[WS RECV]', 'color: #86efac; font-weight: bold', msg);

            switch (msg.type) {
                case 'connected':
                    console.log('%c[CONNECTED]', 'color: #4ade80; font-weight: bold', msg);
                    displayConnectionInfo(msg);
                    break;
                case 'response':
                    console.log('%c[RESPONSE]', 'color: #fbbf24; font-weight: bold', {
                        id: msg.id,
                        resultKeys: msg.result ? Object.keys(msg.result) : null,
                        result: msg.result
                    });
                    // Check if this is an index info response - update all repo cards
                    if (msg.result && msg.result.indexes) {
                        // Update the call graph scope selector with all indexes
                        const allIndexes = Object.values(connectedRepos).flatMap(r => r.indexes || []);
                        const combinedIndexes = [...allIndexes, ...msg.result.indexes];
                        updateCallGraphScopeSelector(combinedIndexes);
                    }
                    displayResults(msg.result);
                    break;
                case 'error':
                    console.error('%c[ERROR]', 'color: #f87171; font-weight: bold', msg);
                    displayResults({ error: msg.message, code: msg.code });
                    break;
                case 'event':
                    console.log('%c[EVENT]', 'color: #c084fc; font-weight: bold', msg);
                    // Log event to the event stream panel
                    const repoPath = msg.repo_path || msg.payload?.repo_path || findRepoPathForEvent(msg);
                    logEvent(msg.name, msg.payload, repoPath);
                    displayResults({ event: msg.name, payload: msg.payload });
                    // Auto-refresh indexes when layer_updated event received
                    if (msg.name && msg.name.includes('layer_updated')) {
                        refreshIndexes();
                        // Update repo cards when indexes change
                        setTimeout(renderConnectedRepos, 200);
                    }
                    break;
                case 'subscribed':
                    console.log('%c[SUBSCRIBED]', 'color: #22d3ee; font-weight: bold', msg);
                    subscriptions = [...new Set([...subscriptions, ...msg.events])];
                    updateSubscriptions();
                    break;
                case 'unsubscribed':
                    console.log('%c[UNSUBSCRIBED]', 'color: #fb7185; font-weight: bold', msg);
                    subscriptions = subscriptions.filter(s => !msg.events.includes(s));
                    updateSubscriptions();
                    break;
            }
        }

        function refreshIndexes() {
            send({
                type: 'query',
                id: queryId++,
                method: 'get_index_info',
                params: {}
            });
        }

        function displayConnectionInfo(info) {
            // Store the repo connection info
            connectedRepos[info.repo_id] = info;
            renderConnectedRepos();

            // Also update the call graph scope selector with all indexes across all repos
            const allIndexes = Object.values(connectedRepos).flatMap(r => r.indexes || []);
            updateCallGraphScopeSelector(allIndexes);

            log(`Connected to repo: ${info.base_repo_path.split('/').pop()} (${info.repo_id})`, 'info');
        }

        function displayResults(result) {
            const resultsEl = document.getElementById('results');
            resultsEl.innerHTML = `<pre>${JSON.stringify(result, null, 2)}</pre>`;
        }

        // updateIndexList and updateWorktreeList removed - now handled by renderConnectedRepos()

        function connectToRepo() {
            const path = document.getElementById('repoPath').value;
            send({ type: 'connect', directory: path });
        }

        function searchSymbols() {
            const query = document.getElementById('searchQuery').value;
            send({
                type: 'query',
                id: queryId++,
                method: 'search_symbols',
                params: { query, limit: 20 }
            });
        }

        function getOverview() {
            send({
                type: 'query',
                id: queryId++,
                method: 'get_overview',
                params: {}
            });
        }

        function listWorktrees() {
            send({
                type: 'query',
                id: queryId++,
                method: 'list_worktrees',
                params: {}
            });
        }

        function getCallGraph() {
            send({
                type: 'query',
                id: queryId++,
                method: 'get_call_graph',
                params: {}
            });
        }

        function customQuery() {
            const method = document.getElementById('customMethod').value;
            let params = {};
            try {
                const paramsStr = document.getElementById('customParams').value;
                if (paramsStr) params = JSON.parse(paramsStr);
            } catch (e) {
                log('Invalid JSON in params', 'error');
                return;
            }
            send({
                type: 'query',
                id: queryId++,
                method,
                params
            });
        }

        function subscribe() {
            const event = document.getElementById('eventType').value;
            send({ type: 'subscribe', events: [event] });
        }

        function unsubscribe() {
            const event = document.getElementById('eventType').value;
            send({ type: 'unsubscribe', events: [event] });
        }

        function updateSubscriptions() {
            document.getElementById('activeSubscriptions').textContent =
                'Active: ' + (subscriptions.length > 0 ? subscriptions.join(', ') : 'none');
        }

        function selectTab(tab) {
            // Hide all tabs
            document.querySelectorAll('[id$="Tab"]').forEach(el => el.style.display = 'none');
            document.querySelectorAll('.tab').forEach(el => el.classList.remove('active'));

            // Show selected tab
            document.getElementById(tab + 'Tab').style.display = 'block';
            event.target.classList.add('active');
        }

        // ============ Call Graph Viewer Functions ============

        let allSymbols = [];
        let selectedSymbolHash = null;
        let currentCallGraph = null;
        let pendingCallGraphRequest = null;
        let availableIndexes = [];

        function updateDepthLabel() {
            document.getElementById('depthLabel').textContent = document.getElementById('graphDepth').value;
        }

        function updateCallGraphScopeSelector(indexes) {
            availableIndexes = indexes || [];
            const select = document.getElementById('callGraphScope');
            const currentValue = select.value;

            if (!indexes || indexes.length === 0) {
                select.innerHTML = '<option value="">-- No indexes available --</option>';
                document.getElementById('scopeSymbolCount').textContent = '';
                return;
            }

            select.innerHTML = indexes.map(idx => `
                <option value="${idx.scope}" data-symbols="${idx.symbol_count}">
                    ${idx.scope} (${idx.symbol_count} symbols)
                </option>
            `).join('');

            // Try to restore previous selection, or select the one with most symbols
            if (currentValue && indexes.find(i => i.scope === currentValue)) {
                select.value = currentValue;
            } else {
                // Select the index with the most symbols (usually a worktree)
                const maxIndex = indexes.reduce((max, idx) =>
                    idx.symbol_count > max.symbol_count ? idx : max, indexes[0]);
                select.value = maxIndex.scope;
            }

            updateScopeSymbolCount();
        }

        function updateScopeSymbolCount() {
            const select = document.getElementById('callGraphScope');
            const option = select.selectedOptions[0];
            if (option && option.dataset.symbols) {
                document.getElementById('scopeSymbolCount').textContent =
                    `${option.dataset.symbols} symbols in this index`;
            } else {
                document.getElementById('scopeSymbolCount').textContent = '';
            }
        }

        function onScopeChange() {
            updateScopeSymbolCount();
            // Clear the symbol list when scope changes
            allSymbols = [];
            selectedSymbolHash = null;
            document.getElementById('symbolListView').innerHTML =
                '<li class="no-data">Click "Load Symbols" to load from selected scope</li>';
            document.getElementById('callGraphView').innerHTML =
                '<div class="no-data">Select a symbol from the list to view its call graph</div>';
        }

        function getSelectedScope() {
            const select = document.getElementById('callGraphScope');
            return select.value || null;
        }

        function loadSymbolList() {
            const scope = getSelectedScope();
            if (!scope) {
                log('No scope selected - connect to a repo first', 'error');
                return;
            }

            pendingCallGraphRequest = 'symbol_list';
            send({
                type: 'query',
                id: queryId++,
                method: 'list_all_symbols',
                params: { limit: 1000, scope }
            });
            log(`Loading all symbols from scope: ${scope}`, 'info');
        }

        // Helper to normalize symbol object (server uses short names: s, h, k, m, f, l, r)
        function normalizeSymbol(s) {
            return {
                symbol: s.symbol || s.s || '',
                hash: s.hash || s.h || '',
                kind: s.kind || s.k || '',
                module: s.module || s.m || '',
                file: s.file || s.f || '',
                lines: s.lines || s.l || '',
                risk: s.risk || s.r || ''
            };
        }

        function filterSymbols() {
            const filter = document.getElementById('symbolSearch').value.toLowerCase();
            const listEl = document.getElementById('symbolListView');

            const filtered = allSymbols.filter(s => {
                const ns = normalizeSymbol(s);
                return ns.symbol.toLowerCase().includes(filter) ||
                    (ns.module && ns.module.toLowerCase().includes(filter)) ||
                    (ns.kind && ns.kind.toLowerCase().includes(filter));
            });

            renderSymbolList(filtered);
        }

        function renderSymbolList(symbols) {
            const listEl = document.getElementById('symbolListView');

            if (!symbols || symbols.length === 0) {
                listEl.innerHTML = '<li class="no-data">No symbols found</li>';
                return;
            }

            listEl.innerHTML = symbols.map(s => {
                const ns = normalizeSymbol(s);
                return `
                <li onclick="selectSymbol('${ns.hash}', '${escapeHtml(ns.symbol)}')" ${selectedSymbolHash === ns.hash ? 'class="selected"' : ''}>
                    <span class="symbol-kind">${ns.kind || 'unknown'}</span>
                    <strong>${escapeHtml(ns.symbol)}</strong>
                    ${ns.module ? `<span class="symbol-module">${escapeHtml(ns.module)}</span>` : ''}
                </li>
            `}).join('');
        }

        function escapeHtml(str) {
            if (!str) return '';
            return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
        }

        function selectSymbol(hash, name) {
            selectedSymbolHash = hash;
            // Update selection highlight
            document.querySelectorAll('#symbolListView li').forEach(li => li.classList.remove('selected'));
            event.target.closest('li').classList.add('selected');

            // Fetch call graph for this symbol
            const depth = parseInt(document.getElementById('graphDepth').value);
            const scope = getSelectedScope();
            pendingCallGraphRequest = 'call_graph_for_symbol';
            send({
                type: 'query',
                id: queryId++,
                method: 'get_call_graph_for_symbol',
                params: { hash, depth, scope }
            });

            // Show loading state
            document.getElementById('callGraphView').innerHTML = `
                <div class="no-data">Loading call graph for ${escapeHtml(name)}...</div>
            `;
        }

        function handleSymbolListResponse(result) {
            console.log('%c[SYMBOL LIST RESPONSE]', 'color: #f472b6; font-weight: bold', {
                hasResults: !!result.results,
                hasSymbols: !!result.symbols,
                resultsLength: result.results?.length,
                symbolsLength: result.symbols?.length,
                scope: result.scope,
                fullResult: result
            });

            // list_all_symbols returns 'symbols', search_symbols returns 'results'
            const symbols = result.symbols || result.results || [];

            // Log raw and normalized samples
            console.log('%c[SYMBOLS ARRAY - RAW]', 'color: #a78bfa; font-weight: bold', {
                length: symbols.length,
                firstSymbolRaw: symbols[0],
                sampleSymbolsRaw: symbols.slice(0, 3)
            });

            if (symbols.length > 0) {
                console.log('%c[SYMBOLS ARRAY - NORMALIZED]', 'color: #34d399; font-weight: bold', {
                    firstSymbolNormalized: normalizeSymbol(symbols[0]),
                    sampleSymbolsNormalized: symbols.slice(0, 3).map(normalizeSymbol)
                });
            }

            if (symbols && symbols.length > 0) {
                allSymbols = symbols;
                renderSymbolList(allSymbols);
                const first = normalizeSymbol(symbols[0]);
                log(`Loaded ${allSymbols.length} symbols for call graph viewer from scope: ${result.scope || 'unknown'} (first: ${first.symbol})`, 'info');
            } else {
                allSymbols = [];
                document.getElementById('symbolListView').innerHTML =
                    '<li class="no-data">No symbols found in this scope. Try a different index or re-index.</li>';
                log(`No symbols returned from scope: ${result.scope || 'unknown'}`, 'info');
            }
        }

        function handleCallGraphForSymbolResponse(result) {
            console.log('%c[CALL GRAPH RESPONSE]', 'color: #fb923c; font-weight: bold', {
                center: result.center,
                upstreamCount: result.upstream?.length,
                downstreamCount: result.downstream?.length,
                depth: result.depth,
                scope: result.scope,
                fullResult: result
            });
            currentCallGraph = result;
            renderCallGraphView(result);
        }

        function renderCallGraphView(data) {
            const view = document.getElementById('callGraphView');

            if (!data || !data.center) {
                view.innerHTML = '<div class="no-data">No call graph data available</div>';
                return;
            }

            const { center, upstream, downstream, depth, scope } = data;
            const upstreamCount = countNodes(upstream);
            const downstreamCount = countNodes(downstream);

            let html = `
                <div class="stats-bar">
                    <div class="stat">
                        <span>Scope:</span>
                        <span class="stat-value">${escapeHtml(scope || 'base_branch')}</span>
                    </div>
                    <div class="stat">
                        <span>Callers (fan-in):</span>
                        <span class="stat-value">${upstreamCount}</span>
                    </div>
                    <div class="stat">
                        <span>Callees (fan-out):</span>
                        <span class="stat-value">${downstreamCount}</span>
                    </div>
                    <div class="stat">
                        <span>Depth:</span>
                        <span class="stat-value">${depth}</span>
                    </div>
                </div>

                <!-- Upstream (Callers) -->
                <div class="graph-section">
                    <div class="graph-section-title">
                        <span class="arrow">&#8593;</span> Who calls this symbol (upstream)
                    </div>
                    ${upstream && upstream.length > 0
                        ? renderUpstreamTree(upstream)
                        : '<div class="no-data">No callers found</div>'
                    }
                </div>

                <!-- Center Symbol -->
                <div class="center-symbol">
                    <div class="name">${escapeHtml(center.name)}</div>
                    <div class="meta">${center.kind} ${center.module ? '| ' + escapeHtml(center.module) : ''}</div>
                </div>

                <!-- Downstream (Callees) -->
                <div class="graph-section">
                    <div class="graph-section-title">
                        <span class="arrow">&#8595;</span> What this symbol calls (downstream)
                    </div>
                    ${downstream && downstream.length > 0
                        ? renderDownstreamTree(downstream)
                        : '<div class="no-data">No callees found</div>'
                    }
                </div>
            `;

            view.innerHTML = html;
        }

        function countNodes(nodes) {
            if (!nodes || nodes.length === 0) return 0;
            let count = nodes.length;
            for (const node of nodes) {
                if (node.children) count += countNodes(node.children);
                if (node.parents) count += countNodes(node.parents);
            }
            return count;
        }

        function renderUpstreamTree(nodes, level = 0) {
            if (!nodes || nodes.length === 0) return '';

            return nodes.map(node => {
                const hasParents = node.parents && node.parents.length > 0;
                const nodeId = `up-${node.hash}-${level}`;

                return `
                    <div class="tree-node">
                        ${hasParents ? renderUpstreamTree(node.parents, level + 1) : ''}
                        <div class="tree-item ${hasParents ? 'has-children expanded' : ''}"
                             onclick="navigateToSymbol('${node.hash}', '${escapeHtml(node.name)}')"
                             title="Click to focus on this symbol">
                            <span class="name">${escapeHtml(node.name)}</span>
                            <span class="kind">${node.kind}</span>
                            ${node.module ? `<span class="module">${escapeHtml(node.module)}</span>` : ''}
                        </div>
                    </div>
                `;
            }).join('');
        }

        function renderDownstreamTree(nodes, level = 0) {
            if (!nodes || nodes.length === 0) return '';

            return nodes.map(node => {
                const hasChildren = node.children && node.children.length > 0;
                const nodeId = `down-${node.hash}-${level}`;

                return `
                    <div class="tree-node">
                        <div class="tree-item ${hasChildren ? 'has-children expanded' : ''}"
                             onclick="navigateToSymbol('${node.hash}', '${escapeHtml(node.name)}')"
                             title="Click to focus on this symbol">
                            <span class="name">${escapeHtml(node.name)}</span>
                            <span class="kind">${node.kind}</span>
                            ${node.module ? `<span class="module">${escapeHtml(node.module)}</span>` : ''}
                        </div>
                        ${hasChildren ? renderDownstreamTree(node.children, level + 1) : ''}
                    </div>
                `;
            }).join('');
        }

        function navigateToSymbol(hash, name) {
            // Update selection in symbol list
            selectedSymbolHash = hash;
            document.querySelectorAll('#symbolListView li').forEach(li => {
                if (li.onclick && li.onclick.toString().includes(hash)) {
                    li.classList.add('selected');
                } else {
                    li.classList.remove('selected');
                }
            });

            // Fetch new call graph
            const depth = parseInt(document.getElementById('graphDepth').value);
            const scope = getSelectedScope();
            pendingCallGraphRequest = 'call_graph_for_symbol';
            send({
                type: 'query',
                id: queryId++,
                method: 'get_call_graph_for_symbol',
                params: { hash, depth, scope }
            });

            document.getElementById('callGraphView').innerHTML = `
                <div class="no-data">Loading call graph for ${escapeHtml(name)}...</div>
            `;

            log(`Navigating to symbol: ${name}`, 'info');
        }

        // Extend handleMessage to handle call graph responses
        const originalHandleMessage = handleMessage;
        handleMessage = function(msg) {
            // Check for call graph specific responses
            if (msg.type === 'response' && pendingCallGraphRequest) {
                // search_symbols returns 'results' (or 'symbols' for legacy)
                if (pendingCallGraphRequest === 'symbol_list' && msg.result && (msg.result.results || msg.result.symbols)) {
                    handleSymbolListResponse(msg.result);
                    pendingCallGraphRequest = null;
                    displayResults(msg.result);
                    return;
                }
                if (pendingCallGraphRequest === 'call_graph_for_symbol' && msg.result && msg.result.center) {
                    handleCallGraphForSymbolResponse(msg.result);
                    pendingCallGraphRequest = null;
                    displayResults(msg.result);
                    return;
                }
            }
            // Fall through to original handler
            originalHandleMessage(msg);
        };
    </script>
</body>
</html>
